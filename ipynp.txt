cell 1:



import pandas as pd
from sklearn.preprocessing import LabelEncoder
import seaborn as sns
import matplotlib.pyplot as plt

data_1=pd.read_csv('McKesson_Large_Demand_Forecasting_Dataset.csv')
data_2=pd.read_csv('daily_dataset_2023.csv')
data_1.drop(columns=['product_id','region'], inplace=True)
# data_1['date']=pd.to_datetime(data_1['date'])
# data_2['date']=pd.to_datetime(data_1['date'])
data_1['month_day'] = data_1['date'].str[5:10]
data_2['month_day'] = data_2['date'].str[5:10]
merged_df = pd.merge(data_1, data_2[['month_day', 'season']], 
                     on='month_day', 
                     how='left')
merged_df['month_And_day'] = merged_df['date'].str[0:7]
# print(merged_df['month_And_day'])

merged_df['date']=pd.to_datetime(merged_df['date'])
print(merged_df.columns)
# print(merged_df['month_day'])
merged_df['month_day']=merged_df['month_day'].str[3:5].astype(int)
merged_df['day_of_week'] = merged_df['date'].dt.weekday        # 0=Monday, 6=Sunday
merged_df['week_of_month'] = merged_df['date'].apply(lambda d: (d.day-1)//7 + 1)
merged_df['month'] = merged_df['date'].dt.month
merged_df['is_weekend'] = (merged_df['day_of_week'] >= 5).astype(int)
merged_df['lag_1'] = merged_df['units_sold'].shift(1)   
merged_df['lag_7'] = merged_df['units_sold'].shift(7)
merged_df['roll_mean_7'] = merged_df['units_sold'].shift(1).rolling(7).mean()
merged_df['roll_std_7']  = merged_df['units_sold'].shift(1).rolling(7).std()
merged_df['roll_sum_30'] = merged_df['units_sold'].shift(1).rolling(30).sum()
print(merged_df)
merged_df.dropna(inplace=True)
# missing_count = merged_df['units_sold'].isnull().sum()
# print(missing_count)
print(merged_df['roll_sum_30'].head(100))
merged_df_label_encoded=merged_df.copy()
merged_df_label_encoded['medicine_season'] = merged_df_label_encoded['product_name'].astype(str) + "_" + merged_df_label_encoded['season'].astype(str)
merged_df_label_encoded['medicine_flu'] = merged_df_label_encoded['product_name'].astype(str) + "_" + merged_df_label_encoded['flu_alert_level'].astype(str)
for col in ['product_name','category','flu_alert_level','season','medicine_season','medicine_flu']:
    if col in merged_df_label_encoded.columns:
        le = LabelEncoder()
        merged_df_label_encoded[col] = le.fit_transform(merged_df_label_encoded[col].astype(str))
        print("Mapping:", dict(zip(le.classes_, le.transform(le.classes_))))

print(merged_df_label_encoded['month'].tail(100))
print(merged_df_label_encoded['roll_sum_30'].head(30))
print(merged_df_label_encoded['week_of_month'].tail(100))



# Encode them




# le_1 = LabelEncoder()
# le_2 = LabelEncoder()
# merged_df['medicine_type_encoded'] = le_1.fit_transform(merged_df['product_name'])
# merged_df['category_encoded'] = le_2.fit_transform(merged_df['category'])

# merged_df.drop(columns=['date'], inplace=True)
print(merged_df_label_encoded.columns)
print(merged_df_label_encoded)

# print(merged_df['roll_mean_7'].head(10))
# print(merged_df['medicine_type_encoded'])
# print("Mapping:", dict(zip(le_1.classes_, le_1.transform(le_1.classes_))))
# print(merged_df['medicine_type_encoded'])
# print("Mapping:", dict(zip(le_2.classes_, le_2.transform(le_2.classes_))))
plt.figure(figsize=(8,6))
sns.boxplot(x='product_name', y='units_sold', data=merged_df_label_encoded)
plt.title("Demand distribution by Medicine Type")
plt.show()








cell 2:


# merged_df = merged_df.sort_values('date').reset_index(drop=True)
def inv_boxcox(y_transformed, lambda_value):
    if lambda_value == 0:
        return np.exp(y_transformed)
    else:
        return (y_transformed * lambda_value + 1) ** (1 / lambda_value)

from xgboost import XGBRegressor
from sklearn.preprocessing import StandardScaler
from lightgbm import LGBMRegressor
from sklearn.model_selection import GridSearchCV, TimeSeriesSplit
from prophet import Prophet
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np
import matplotlib.pyplot as plt
from sklearn.feature_selection import SelectFromModel
from scipy import stats


selected_columns=['date', 'product_name', 'category', 'units_sold', 'unit_price',
       'market_trend_index', 'is_holiday', 'flu_alert_level', 'economic_index',
       'month_day', 'season', 'day_of_week', 'week_of_month', 'month',
       'is_weekend', 'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7',
       'roll_sum_30','medicine_season','medicine_flu','month_And_day'];
selected_columns_prophet=['date', 'product_name', 'category', 'units_sold', 'unit_price',
       'market_trend_index', 'is_holiday', 'flu_alert_level', 'economic_index',
       'month_day', 'season', 'day_of_week', 'week_of_month', 'month',
       'is_weekend', 'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7',
       'roll_sum_30','month_And_day'];

rf_model_amoxicillin = RandomForestRegressor(
    n_estimators=300,      # number of trees
    max_depth=5,          # limit depth
    random_state=42,
    n_jobs=-1            
    , min_samples_split=10         # use all cores
    )
rf_model_atorvastatin = RandomForestRegressor(
    n_estimators=300,      # number of trees
    max_depth=5,          # limit depth
    random_state=42,
    n_jobs=-1  
    , min_samples_split=10       # use all cores
    )
lgbm_params_insulin_glargine = {
   "objective": "regression",
    "metric": "rmse",
    "boosting_type": "gbdt",

    "n_estimators": 800,
    "learning_rate": 0.03,

    "num_leaves": 31,          # keep small to avoid overfitting
    "max_depth": -1,           # let LGBM decide

    "min_child_samples": 30,   # VERY important for noisy data
    "subsample": 0.8,
    "subsample_freq": 1,

    "colsample_bytree": 0.8,

    "reg_alpha": 0.5,          # L1 regularization
    "reg_lambda": 1.0,         # L2 regularization

    "random_state": 42,
    "n_jobs": -1


   }
lgbm_params_surgical_gloves_box = {
    "objective": "regression",
    "metric": "rmse",
    "boosting_type": "gbdt",

    "n_estimators": 800,
    "learning_rate": 0.03,

    "num_leaves": 31,          # keep small to avoid overfitting
    "max_depth": -1,           # let LGBM decide

    "min_child_samples": 30,   # VERY important for noisy data
    "subsample": 0.8,
    "subsample_freq": 1,

    "colsample_bytree": 0.8,

    "reg_alpha": 0.5,          # L1 regularization
    "reg_lambda": 1.0,         # L2 regularization

    "random_state": 42,
    "n_jobs": -1
   }
lgb_model_insulin_glargine = LGBMRegressor(
    **lgbm_params_insulin_glargine
    )
lgb_model_surgical_gloves_box = LGBMRegressor(
    **lgbm_params_surgical_gloves_box
    )
xg_model_surgical_masks_box = XGBRegressor(
      n_estimators=600,
    learning_rate=0.03,
    max_depth=5,
    min_child_weight=5,
    subsample=0.85,
    colsample_bytree=0.85,
    reg_alpha=1.0,
    reg_lambda=2.0,
    objective="reg:squarederror",
    random_state=42
      )

rf_model_amoxicillin_K_fold = RandomForestRegressor(
    n_estimators=300,      # number of trees
    max_depth=5,          # limit depth
    random_state=42,
    n_jobs=-1            
    , min_samples_split=10         # use all cores
    )
rf_model_atorvastatin_K_fold = RandomForestRegressor(
    n_estimators=300,      # number of trees
    max_depth=5,          # limit depth
    random_state=42,
    n_jobs=-1  
    , min_samples_split=10       # use all cores
    )
lgbm_params_insulin_glargine_K_fold = {
   "objective": "regression",
    "metric": "rmse",
    "boosting_type": "gbdt",

    "n_estimators": 800,
    "learning_rate": 0.03,

    "num_leaves": 31,          # keep small to avoid overfitting
    "max_depth": -1,           # let LGBM decide

    "min_child_samples": 30,   # VERY important for noisy data
    "subsample": 0.8,
    "subsample_freq": 1,

    "colsample_bytree": 0.8,

    "reg_alpha": 0.5,          # L1 regularization
    "reg_lambda": 1.0,         # L2 regularization

    "random_state": 42,
    "n_jobs": -1


   }
lgbm_params_surgical_gloves_box_K_fold = {
    "objective": "regression",
    "metric": "rmse",
    "boosting_type": "gbdt",

    "n_estimators": 800,
    "learning_rate": 0.03,

    "num_leaves": 31,          # keep small to avoid overfitting
    "max_depth": -1,           # let LGBM decide

    "min_child_samples": 30,   # VERY important for noisy data
    "subsample": 0.8,
    "subsample_freq": 1,

    "colsample_bytree": 0.8,

    "reg_alpha": 0.5,          # L1 regularization
    "reg_lambda": 1.0,         # L2 regularization

    "random_state": 42,
    "n_jobs": -1
   }
lgb_model_insulin_glargine_K_fold = LGBMRegressor(
    **lgbm_params_insulin_glargine
    )
lgb_model_surgical_gloves_box_K_fold = LGBMRegressor(
    **lgbm_params_surgical_gloves_box
    )
xg_model_surgical_masks_box_K_fold = XGBRegressor(
      n_estimators=600,
    learning_rate=0.03,
    max_depth=5,
    min_child_weight=5,
    subsample=0.85,
    colsample_bytree=0.85,
    reg_alpha=1.0,
    reg_lambda=2.0,
    objective="reg:squarederror",
    random_state=42
      )


my_dict = {'Amoxicillin 500mg': 0, "Atorvastatin 20mg": 1, "Insulin Glargine 10ml": 2,"Surgical Gloves Box":3,"Surgical Masks Box":4}
for key, value in my_dict.items():
    print(f"{key}: {value}")
    new_dataset = merged_df_label_encoded.loc[merged_df_label_encoded['product_name'] == value, selected_columns]
    # prophet_dataset = merged_df.loc[merged_df['product_name'] == key, selected_columns_prophet]
    # print(prophet_dataset)
    # print(new_dataset.columns)
    
    # print(new_dataset[['date','month_And_day', 'week_of_month','week_of_month','units_sold']].head(20))
    # print(new_dataset.shape[0])
    # print(new_dataset.head(10))
    # average_df = new_dataset.groupby(['month_And_day', 'week_of_month'],as_index=False).mean()
    average_df = new_dataset.groupby(['month_And_day', 'week_of_month']).agg(
    {'date': 'first', 'product_name': 'mean', 'category': 'mean', 'units_sold': 'mean', 'unit_price': 'mean',
       'market_trend_index': 'mean', 'is_holiday': 'mean', 'flu_alert_level': 'mean', 'economic_index': 'mean',
       'month_day': 'mean', 'season': 'mean', 'day_of_week': 'mean',  'month': 'mean',
       'is_weekend': 'mean', 'lag_1': 'mean', 'lag_7': 'mean', 'roll_mean_7': 'mean', 'roll_std_7': 'mean',
       'roll_sum_30': 'mean','medicine_season': 'mean','medicine_flu': 'mean'})


    result_df = average_df.reset_index()
    # print(result_df.columns)
    # print(result_df.count)
    cutoff = int(len(result_df) * 0.8)
    train = result_df.iloc[:cutoff]
    test  = result_df.iloc[cutoff:]
    # test['DateString'] = test['date'].astype(str)


    features = [ 'flu_alert_level'
       , 'season',  'week_of_month', 'month',
        'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7'
         ]
    X_train, y_train = train[features], train['units_sold']
    X_test,  y_test  = test[features],  test['units_sold']
    corr_matrix = X_train.corr()
    # upper_triangle = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    # to_drop = [column for column in upper_triangle.columns if any(upper_triangle[column] > 0.9)]
    
    # print("columns to drop due to high correlation:")
    # print(to_drop)
    y_train_transformed, lambda_value = stats.boxcox(y_train)
    y_train_transformed_log = np.log1p(y_train)
    if value == 0:
          plt.figure(figsize=(12, 8))
          sns.heatmap(corr_matrix, annot=True, cmap='coolwarm')
          plt.show()

    # print(result_df.head(20))
    # print(result_df.shape[0])
    # print(new_dataset)
    # df['demand_log'] = np.log1p(df['demand'])
    if key == "Amoxicillin 500mg":
        
    # X_train_selected = X_train.drop(columns=to_drop)
        
        
        rf_model_amoxicillin.fit(X_train, y_train_transformed)
        pred = rf_model_amoxicillin.predict(X_test)
        y_pred = inv_boxcox(pred, lambda_value)
        y_pred_rf= y_pred.copy()
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
        print("Random Forest Model "+f"MAE: {mae:.2f} | RMSE: {rmse:.2f}" + " | MAPE:", mape)

        plt.figure(figsize=(10,4))
        plt.scatter(y_test, y_test - y_pred_rf, alpha=0.6, color='blue')
        plt.axhline(0, color='red', linestyle='--')
        plt.xlabel("Actual Demand")
        plt.ylabel("Residuals (y_test - y_pred_rf)")
        plt.title("Residuals: Random Forest")

        plt.figure(figsize=(10,4))
        plt.plot(test['date'], y_test - y_pred, label='Residuals_RandomForest')
        plt.axhline(0, color='red', linestyle='--')
        plt.title("Residuals over time")
        plt.legend()
        plt.show()
        tscv_xg = TimeSeriesSplit(n_splits=3)
        x = result_df[[
        'flu_alert_level'
       , 'season',  'week_of_month', 'month',
        'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7'
          ]]
        y = result_df['units_sold']
        mae_scores = []
        rmse_scores = []
        mape_scores = []
        print("cross validation for Amoxicillin 500mg model")
        for fold, (train_idx, test_idx) in enumerate(tscv_xg.split(x)):
           X_train_0, X_test_0 = x.iloc[train_idx], x.iloc[test_idx]
           y_train_0, y_test_0 = y.iloc[train_idx], y.iloc[test_idx]
           print("Train set NaN values:", np.isnan(X_train_0).sum(), np.isinf(X_train_0).sum())
           print("Test set NaN values:", np.isnan(X_test_0).sum(), np.isinf(X_test_0).sum())
           y_train_transformed, lambda_value = stats.boxcox(y_train_0)
           rf_model_amoxicillin_K_fold.fit(X_train_0, y_train_transformed)
           pred = rf_model_amoxicillin_K_fold.predict(X_test_0)
           y_pred = inv_boxcox(pred, lambda_value)

           mae = mean_absolute_error(y_test_0, y_pred)
           rmse = np.sqrt(mean_squared_error(y_test_0, y_pred))
           mape = np.mean(np.abs((y_test_0 - y_pred) / y_test_0)) * 100
    
           mae_scores.append(mae)
           rmse_scores.append(rmse)
           mape_scores.append(mape)
    
           print(f"Fold {fold+1} - MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")
        print("Average MAE:", np.mean(mae_scores))
        print("Average RMSE:", np.mean(rmse_scores))
        print("Average MAPE:", np.mean(mape_scores))
           

        
    elif key == "Atorvastatin 20mg":
        rf_model_atorvastatin.fit(X_train, y_train_transformed)
        pred = rf_model_atorvastatin.predict(X_test)
        y_pred = inv_boxcox(pred, lambda_value)
        y_pred_rf= y_pred.copy()
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
        print("Random Forest Model "+f"MAE: {mae:.2f} | RMSE: {rmse:.2f}" + " | MAPE:", mape)

        plt.figure(figsize=(10,4))
        plt.scatter(y_test, y_test - y_pred_rf, alpha=0.6, color='blue')
        plt.axhline(0, color='red', linestyle='--')
        plt.xlabel("Actual Demand")
        plt.ylabel("Residuals (y_test - y_pred_rf)")
        plt.title("Residuals: Random Forest") 
        
        plt.figure(figsize=(10,4))
        plt.plot(test['date'], y_test - y_pred, label='Residuals_RandomForest')
        plt.axhline(0, color='red', linestyle='--')
        plt.title("Residuals over time")
        plt.legend()
        plt.show()

        tscv_xg = TimeSeriesSplit(n_splits=3)
        x = result_df[[
        'flu_alert_level'
       , 'season',  'week_of_month', 'month',
        'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7'
          ]]
        y = result_df['units_sold']
        mae_scores = []
        rmse_scores = []
        mape_scores = []
        print("cross validation for Atorvastatin 20mg model")
        for fold, (train_idx, test_idx) in enumerate(tscv_xg.split(x)):
           X_train_0, X_test_0 = x.iloc[train_idx], x.iloc[test_idx]
           y_train_0, y_test_0 = y.iloc[train_idx], y.iloc[test_idx]
           print("Train set NaN values:", np.isnan(X_train_0).sum(), np.isinf(X_train_0).sum())
           print("Test set NaN values:", np.isnan(X_test_0).sum(), np.isinf(X_test_0).sum())
           y_train_transformed, lambda_value = stats.boxcox(y_train_0)
           rf_model_atorvastatin_K_fold.fit(X_train_0, y_train_transformed)
           pred = rf_model_atorvastatin_K_fold.predict(X_test_0)
           y_pred = inv_boxcox(pred, lambda_value)

           mae = mean_absolute_error(y_test_0, y_pred)
           rmse = np.sqrt(mean_squared_error(y_test_0, y_pred))
           mape = np.mean(np.abs((y_test_0 - y_pred) / y_test_0)) * 100
    
           mae_scores.append(mae)
           rmse_scores.append(rmse)
           mape_scores.append(mape)
    
           print(f"Fold {fold+1} - MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")
        print("Average MAE:", np.mean(mae_scores))
        print("Average RMSE:", np.mean(rmse_scores))
        print("Average MAPE:", np.mean(mape_scores))

        

    elif key == "Insulin Glargine 10ml":
        lgb_model_insulin_glargine.fit(X_train, y_train_transformed_log)
        pred = lgb_model_insulin_glargine.predict(X_test)
        y_pred = np.expm1(pred)
        y_pred_lgb= y_pred.copy()
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
        print("LGBM Model "+f"MAE: {mae:.2f} | RMSE: {rmse:.2f}" + " | MAPE:", mape)

        plt.figure(figsize=(10,4))
        plt.scatter(y_test, y_test - y_pred_lgb, alpha=0.6, color='blue')
        plt.axhline(0, color='red', linestyle='--')
        plt.xlabel("Actual Demand")
        plt.ylabel("Residuals (y_test - y_pred_lgb)")
        plt.title("Residuals: Light GBM")

        plt.figure(figsize=(10,4))
        plt.plot(test['date'], y_test - y_pred, label='Residuals_LGBM')
        plt.axhline(0, color='red', linestyle='--')
        plt.title("Residuals over time")
        plt.legend()
        plt.show()
        tscv_lgbm = TimeSeriesSplit(n_splits=3)
        x = result_df[[
        'flu_alert_level'
       , 'season',  'week_of_month', 'month',
        'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7'
          ]]
        y = result_df['units_sold']
        mae_scores = []
        rmse_scores = []
        mape_scores = []
        print("cross validation for Insulin Glargine 10ml model")
        for fold, (train_idx, test_idx) in enumerate(tscv_lgbm.split(x)):
           X_train_1, X_test_1 = x.iloc[train_idx], x.iloc[test_idx]
           y_train_1, y_test_1 = y.iloc[train_idx], y.iloc[test_idx]
           y_train_transformed, lambda_value = stats.boxcox(y_train_1)
           lgb_model_insulin_glargine_K_fold.fit(X_train_1, y_train_transformed)
           pred = lgb_model_insulin_glargine_K_fold.predict(X_test_1)
           y_pred_1 = inv_boxcox(pred, lambda_value)
           mean_y_test = np.nanmean(y_test_1)
           mean_y_pred = np.nanmean(y_pred_1)  
           y_pred = np.nan_to_num(y_pred_1, nan=mean_y_pred, posinf=mean_y_pred, neginf=mean_y_pred)
           y_test = np.nan_to_num(y_test_1, nan=mean_y_test, posinf=mean_y_test, neginf=mean_y_test)
           mae = mean_absolute_error(y_test, y_pred)
           rmse = np.sqrt(mean_squared_error(y_test, y_pred))
           mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
           mae_scores.append(mae)
           rmse_scores.append(rmse)
           mape_scores.append(mape)
           print(f"Fold {fold+1} - MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")

        print("Average MAE:", np.mean(mae_scores))
        print("Average RMSE:", np.mean(rmse_scores))
        print("Average MAPE:", np.mean(mape_scores))

        
    elif key == "Surgical Gloves Box":
        lgb_model_surgical_gloves_box.fit(X_train, y_train_transformed_log)
        pred = lgb_model_surgical_gloves_box.predict(X_test)
        y_pred = np.expm1(pred)
        y_pred_lgb= y_pred.copy()
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
        print("LGBM Model "+f"MAE: {mae:.2f} | RMSE: {rmse:.2f}" + " | MAPE:", mape)

        plt.scatter(y_test, y_test - y_pred_lgb, alpha=0.6, color='blue')
        plt.axhline(0, color='red', linestyle='--')
        plt.xlabel("Actual Demand")
        plt.ylabel("Residuals (y_test - y_pred_lgb)")
        plt.title("Residuals: Light GBM")

        plt.figure(figsize=(10,4))
        plt.plot(test['date'], y_test - y_pred, label='Residuals_LGBM')
        plt.axhline(0, color='red', linestyle='--')
        plt.title("Residuals over time")
        plt.legend()
        plt.show()

        tscv_lgbm = TimeSeriesSplit(n_splits=3)
        x = result_df[[
        'flu_alert_level'
       , 'season',  'week_of_month', 'month',
        'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7'
          ]]
        y = result_df['units_sold']
        mae_scores = []
        rmse_scores = []
        mape_scores = []
        print("cross validation for Surgical Gloves Box model")
        for fold, (train_idx, test_idx) in enumerate(tscv_lgbm.split(x)):
           X_train_1, X_test_1 = x.iloc[train_idx], x.iloc[test_idx]
           y_train_1, y_test_1 = y.iloc[train_idx], y.iloc[test_idx]
           y_train_transformed, lambda_value = stats.boxcox(y_train_1)
           lgb_model_surgical_gloves_box_K_fold.fit(X_train_1, y_train_transformed)
           pred = lgb_model_surgical_gloves_box_K_fold.predict(X_test_1)
           y_pred_1 = inv_boxcox(pred, lambda_value)
           mean_y_test = np.nanmean(y_test_1)
           mean_y_pred = np.nanmean(y_pred_1)  
           y_pred = np.nan_to_num(y_pred_1, nan=mean_y_pred, posinf=mean_y_pred, neginf=mean_y_pred)
           y_test = np.nan_to_num(y_test_1, nan=mean_y_test, posinf=mean_y_test, neginf=mean_y_test)
           mae = mean_absolute_error(y_test, y_pred)
           rmse = np.sqrt(mean_squared_error(y_test, y_pred))
           mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
           mae_scores.append(mae)
           rmse_scores.append(rmse)
           mape_scores.append(mape)
           print(f"Fold {fold+1} - MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")

        print("Average MAE:", np.mean(mae_scores))
        print("Average RMSE:", np.mean(rmse_scores))
        print("Average MAPE:", np.mean(mape_scores))

        # plt.figure(figsize=(10,4))
        
    else:
        xg_model_surgical_masks_box.fit(X_train, y_train_transformed)
        pred = xg_model_surgical_masks_box.predict(X_test)
        y_pred = inv_boxcox(pred, lambda_value)
        y_pred_xg = y_pred.copy()
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
        print("XGBoost Model "+f"MAE: {mae:.2f} | RMSE: {rmse:.2f}" + " | MAPE:", mape)
    # print(test['date'])
        plt.figure(figsize=(10,4))
        plt.scatter(y_test, y_test - y_pred_xg, alpha=0.6, color='blue')
        plt.axhline(0, color='red', linestyle='--')
        plt.xlabel("Actual Demand")
        plt.ylabel("Residuals (y_test - y_pred_xg)")
        plt.title("Residuals: XGBoost")

        plt.figure(figsize=(10,4))
        plt.plot(test['date'], y_test - y_pred, label='Residuals_XGBoost')
        plt.axhline(0, color='red', linestyle='--')
        plt.title("Residuals over time")
        plt.legend()
        plt.show()
        tscv_xg = TimeSeriesSplit(n_splits=3)
        x = result_df[[
        'flu_alert_level'
       , 'season',  'week_of_month', 'month',
        'lag_1', 'lag_7', 'roll_mean_7', 'roll_std_7'
          ]]
        y = result_df['units_sold']
        mae_scores = []
        rmse_scores = []
        mape_scores = []
        print("cross validation for Surgical Masks Box model")
        for fold, (train_idx, test_idx) in enumerate(tscv_xg.split(x)):
            X_train_2, X_test_2 = x.iloc[train_idx], x.iloc[test_idx]
            y_train_2, y_test_2 = y.iloc[train_idx], y.iloc[test_idx]
            # print("Train set NaN values:", np.isnan(X_train_2).sum(), np.isinf(X_train_2).sum())
            # print("Test set NaN values:", np.isnan(X_test_2).sum(), np.isinf(X_test_2).sum())
            y_train_transformed, lambda_value = stats.boxcox(y_train_2)


            xg_model_surgical_masks_box_K_fold.fit(X_train_2, y_train_transformed)

            pred = xg_model_surgical_masks_box_K_fold.predict(X_test_2)
            y_pred_2 = inv_boxcox(pred, lambda_value)
      
            mean_y_test = np.nanmean(y_test_2)
            mean_y_pred = np.nanmean(y_pred_2)  
            y_pred = np.nan_to_num(y_pred_2, nan=mean_y_pred, posinf=mean_y_pred, neginf=mean_y_pred)
            y_test = np.nan_to_num(y_test_2, nan=mean_y_test, posinf=mean_y_test, neginf=mean_y_test)
            mae = mean_absolute_error(y_test, y_pred)
            rmse = np.sqrt(mean_squared_error(y_test, y_pred))
            mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
            mae_scores.append(mae)
            rmse_scores.append(rmse)
            mape_scores.append(mape)
    
            print(f"Fold {fold+1} - MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")
        print("Average MAE:", np.mean(mae_scores))
        print("Average RMSE:", np.mean(rmse_scores))
        print("Average MAPE:", np.mean(mape_scores))
        









